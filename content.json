{"meta":{"title":"Nan","subtitle":"Calming comes, Wisdom rises.","description":null,"author":"nannanmath","url":"https://nannanmath.github.io"},"pages":[{"title":"About","date":"2017-10-09T04:21:06.332Z","updated":"2017-10-09T04:21:06.332Z","comments":true,"path":"about/index.html","permalink":"https://nannanmath.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-10-09T04:21:06.335Z","updated":"2017-10-09T04:21:06.335Z","comments":false,"path":"categories/index.html","permalink":"https://nannanmath.github.io/categories/index.html","excerpt":"","text":""},{"title":"xuwei","date":"2017-05-25T08:03:20.000Z","updated":"2017-10-09T04:21:06.342Z","comments":true,"path":"xuwei/index.html","permalink":"https://nannanmath.github.io/xuwei/index.html","excerpt":"","text":"This is a new page for Xuwei. The Gift."},{"title":"Tags","date":"2017-10-09T04:21:06.339Z","updated":"2017-10-09T04:21:06.339Z","comments":false,"path":"tags/index.html","permalink":"https://nannanmath.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hadoop-8","slug":"hadoop-8","date":"2017-10-26T02:43:06.000Z","updated":"2017-10-30T04:13:16.148Z","comments":true,"path":"2017/10/26/hadoop-8/","link":"","permalink":"https://nannanmath.github.io/2017/10/26/hadoop-8/","excerpt":"Hdfs writting process.","text":"Hdfs writting process. Set block size Add property Default blocksize is 128m, minimal blocksize is 1m. Edit hdfs-site.xml, add property dfs.blocksize. 12345678&lt;property&gt; &lt;name&gt;dsf.blocksize&lt;/name&gt; &lt;value&gt;2k&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.namenode.fs-limits.min-block-size&lt;/name&gt; &lt;value&gt;1024&lt;/value&gt;&lt;/property&gt; Note: Too small blocksize can degrade performance. Check 1$&gt; hdfs getconf -confKey dfs.blocksize // show blocksize. Restart hadoop and put file 123$&gt; stop-dfs.sh$&gt; start-dfs.sh$&gt; hdfs dfs -put a.txt Put file by Hadoop API 1234567891011121314151617public void putFileWithBlocksize() &#123; Configuration conf = new Configuration(); conf.set(\"fs.defaultFS\", \"hdfs://192.168.137.201:8020/\"); try &#123; FileSystem fs = FileSystem.get(conf); FSDataOutputStream fsdo = fs.create(new Path(\"/usr/win7admin/blocksize.txt\"), true, 1024, (short)2, 1024); // replication: 2; block size: 1024. FileInputStream fis = new FileInputStream(\"D:/HexoSourceCode/source/_posts/new1.md\"); IOUtils.copyBytes(fis, fsdo, 1024); fis.close(); fsdo.close(); System.out.println(\"over!\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; Writting process Concept Packet 64k chunk Checksum each chunk 512 bytes","categories":[{"name":"BigData","slug":"BigData","permalink":"https://nannanmath.github.io/categories/BigData/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://nannanmath.github.io/tags/hadoop/"}]},{"title":"java-nio","slug":"java-nio","date":"2017-10-24T14:28:54.000Z","updated":"2017-10-31T02:14:27.636Z","comments":true,"path":"2017/10/24/java-nio/","link":"","permalink":"https://nannanmath.github.io/2017/10/24/java-nio/","excerpt":"NIO.","text":"NIO. Java non-blocking IO (NIO) Support form JDK 1.4 java.nio.buffer capacity limit position mark Allocate buffer 12ByteBuffer buf = ByteBuffer.allocate(20); // allocate in heap.ByteBuffer buf = ByteBuffer.allocateDirect(20;) // allocate in off-heap. ByteBuffer common operations rewind() : pos=0, mark discard clear() : pos=0, lim=cap, mark discard flip() : lim=pos, pos=0, mark discard reset() : pos=mark slice() : split a buffer at remaining position Garbage Collection (GC)System.gc() Channel FileChannel Copy file by Channel. 12345678910111213141516171819public void copyFile() &#123; try &#123; FileInputStream fis = new FileInputStream(\"TestChannelSrc.txt\"); FileChannel fcin = fis.getChannel(); FileOutputStream fos = new FileOutputStream(\"TestChannelDst.txt\"); FileChannel fcout = fos.getChannel(); ByteBuffer buf = ByteBuffer.allocate(1024 * 50); while(fcin.read(buf) != -1) &#123; buf.flip(); fcout.write(buf); buf.clear(); &#125; fis.close(); fos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; SocketChannel Full code can be found on github. MappedByteBuffer Map File on device to memory synchronizely. Full code can be found on github.","categories":[{"name":"Program","slug":"Program","permalink":"https://nannanmath.github.io/categories/Program/"}],"tags":[{"name":"java","slug":"java","permalink":"https://nannanmath.github.io/tags/java/"}]},{"title":"hadoop-7","slug":"hadoop-7","date":"2017-10-19T07:27:09.000Z","updated":"2017-10-26T07:29:03.999Z","comments":true,"path":"2017/10/19/hadoop-7/","link":"","permalink":"https://nannanmath.github.io/2017/10/19/hadoop-7/","excerpt":"Maven introduction.","text":"Maven introduction. Installation Download from Maven. Unzip and config path. Maven configuration Change repository Edit ${M2_HOME}/conf/settings.xml remote repo &lt;mirror&gt; &lt;profile&gt; Local repo Default repo is ${USER_HOME}/.m2/repository. 1&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; Project control Make pom.xml file in root dir of porject. 1234567&lt;?xml version=\"1.0\"&gt;&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;nan.learnjava&lt;/groupId&gt; &lt;artifactId&gt;testmaven&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/project&gt; Make dirs nan/learnjava/testmaven. Create java source file HelloMaven.java 1234567package nan.learnjava.testmaven;public class HelloMaven &#123; public static void main(String[] args) &#123; System.out.println(\"Hello Maven!\"); &#125;&#125; Compile and run 123$&gt; mvn clean compile // compile$&gt; mvn clean package // package jar$&gt; java -cp testmaven-1.0.0.jar nan.learnjava.testmaven.HelloMaven // run Private Maven Server NEXUS Download nexus-xxx-bundel.zip from NEXUS. Unzip and set path env. Install service 123$&gt; nexus install // install nexus service$&gt; nexus start // start service$&gt; nexus restart // restart service Open in browser Web site: http://localhost:8081/nexus Config of nexus Nexus repository path Edit file ${NEXUS_HOME}/conf/nexus.properties 12applicaton-port=8081 #default portnexus-work=$&#123;bundleBasedir&#125;/../sonatype-work/nexus #default repository path Log in username: admin password: admin123 Update index Repositories –&gt; Central –&gt; Configuration –&gt; Download Remote Indexes –&gt; true Central –&gt; Repair Index Config of Maven Copy ${M2_HOME}/conf/settings.xml to ${HOME}/.m2/ Edit settings.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!--localRepository--&gt;&lt;localRepository&gt;D:/MyApps/mvn-local-repo&lt;/localRepository&gt;&lt;!--mirror--&gt;&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;nexus repo for maven.&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt;&lt;!--profile--&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;central repos from nexus&lt;/name&gt; &lt;url&gt;http://central&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://central&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt;&lt;/profiels&gt;&lt;!--active--&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;&lt;/activeProfiles&gt; Archetype1$&gt; mvn archetype:generate -DarchetypeCatalog=internal Maven for Eclipse Config Preference –&gt; Maven –&gt; User Setting –&gt; Global Settings –&gt; User Settings New Project New –&gt; Project… –&gt; Maven –&gt; Maven Project –&gt; Location –&gt; Next –&gt; … .. Input Group Id, Artifact Id, Version, Package Add dependencies Edit pom.xml file, add dependency. 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"BigData","slug":"BigData","permalink":"https://nannanmath.github.io/categories/BigData/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://nannanmath.github.io/tags/hadoop/"}]},{"title":"hadoop-6","slug":"hadoop-6","date":"2017-10-17T04:29:48.000Z","updated":"2017-10-19T05:36:20.338Z","comments":true,"path":"2017/10/17/hadoop-6/","link":"","permalink":"https://nannanmath.github.io/2017/10/17/hadoop-6/","excerpt":"Hadoop API.","text":"Hadoop API. Preparation Get all .jar files in hadoop-2.7.x/share/hadoop Add to Build Path Build Path –&gt; Configure Build Path… –&gt; Libraries –&gt; Add External JARs… Add all .jar files. Copy log4j.properties file to HadoopAPIDemo/src dir. Hadoop APIThis functions are implemented by Configuration and FileSystem classes. Configuration is for configuring connections to remote HDFS and FileSystem is used to get file system of HDFS. Full Code can be found on github. Read file By URL 1234URL.setURLStreamHandlerFactory(new FsUrlStreamHandlerFactory());URL url = new URL(\"hdfs://192.168.137.201:8020/usr/centos/hadoop/a.txt\");URLConnection conn = url.openConnection();InputStream is = conn.getInputStream(); By API 12345Configuration conf = new Configuration();conf.set(\"fs.defaultFS\", \"hdfs://192.168.137.201:8020\");FileSystem fs = FileSystem.get(conf);Path p = new Path(\"/usr/centos/hadoop/a.txt\");FSDataInputStream fis = fs.open(p); 1234567Configuration conf = new Configuration();conf.set(\"fs.defaultFS\", \"hdfs://192.168.137.201:8020\");FileSystem fs = FileSystem.get(conf);Path p = new Path(\"/usr/centos/hadoop/a.txt\");FSDataInputStream fis = fs.open(p);ByteArrayOutputStream baos = new ByteArrayOutputStream();IOUtils.copyBytes(fis, baos, 1024); // copy in hadoop api Make directory Give write permission: $&gt; hdfs dfs -chmod 777 /usr 12345Configuration conf = new Configuration();conf.set(\"fs.defaultFS\", \"hdfs://192.168.137.201:8020\");FileSystem fs = FileSystem.get(conf);Path p = new Path(\"/usr/win7admin\");fs.mkdirs(p); Put file 1234567Configuration conf = new Configuration();conf.set(\"fs.defaultFS\", \"hdfs://192.168.137.201:8020\");FileSystem fs = FileSystem.get(conf);Path p = new Path(\"/usr/win7admin/win7.txt\");FSDataOutputStream fsdos = fs.create(p);fsdos.writeBytes(\"Hello, Windows7!\");fsdos.close(); Remove file 12345Configuration conf = new Configuration();conf.set(\"fs.defaultFS\", \"hdfs://192.168.137.201:8020\");FileSystem fs = FileSystem.get(conf);Path p = new Path(\"/usr/win7admin\");fs.delete(p, true);","categories":[{"name":"BigData","slug":"BigData","permalink":"https://nannanmath.github.io/categories/BigData/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://nannanmath.github.io/tags/hadoop/"}]},{"title":"hadoop-5","slug":"hadoop-5","date":"2017-10-16T07:01:16.000Z","updated":"2017-10-17T04:29:33.796Z","comments":true,"path":"2017/10/16/hadoop-5/","link":"","permalink":"https://nannanmath.github.io/2017/10/16/hadoop-5/","excerpt":"HDFS basic operations and configurations.","text":"HDFS basic operations and configurations. Commands:1234567891011$&gt; hadoop version // show version of hadoop.$&gt; hadoop fs // hdfs$&gt; hadoop jar/***** File *****/// `hdfs dfs` equal to `hadoop fs`$&gt; hdfs dfs mkdir -p /usr/centos/hadoop // create dir on hdfs.$&gt; hdfs dfs -ls -R / // list dirs on hdfs.$&gt; hdfs dfs -put &lt;localfile&gt; &lt;hdfs dir&gt; // upload a file to hdfs.$&gt; hdfs dfs -rm &lt;remote dir/file&gt; // remove a dir/file on hdfs.$&gt; hdfs dfs -appendToFile &lt;localfile&gt; &lt;hdfsfile&gt; // append a file on hdfs.$&gt; hdfs dfs -cat &lt;hdfsfile&gt; // `cat` a file on hdfs. Block storage Block size Disk seek time: 10ms Disk transmission timr: 100MB/s Block size: 128MB seek : transmission = 1 : 100 Config tmp directory Show all config item for each modules Decompress hadoop-2.7.4.tar.gz Get files share/hadoop/[common | hdfs | mapredude | yarn]/hadoop-xxxx-2.7.4.jar (mapredude –&gt; hadoop-mapreduce-client-core-2.7.4.jar) Decompress that file and get xxxx-default.xml core-site.xml hadoop.tmp.dir is /home/centos01/hadoop 123$&gt; xsync hdfs-site.xml$&gt; hdfs namenode -format // format namenode only$&gt; start-dfs.sh // start hdfs hdfs-site.xml dfs.namenode.name.dir is file://${hadoop.tmp.dir}/dfs/namenode // name node dfs.namenode.data.dir is file://${hadoop.tmp.dir}/dfs/data // data node dfs.namenode.checkpoint.dir is file://${hadoop.tmp.dir}/dfs/namesecondary // secondary name node 123$&gt; xsync hdfs-site.xml$&gt; hdfs namenode -format // format namenode only$&gt; start-dfs.sh // start hdfs","categories":[{"name":"BigData","slug":"BigData","permalink":"https://nannanmath.github.io/categories/BigData/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://nannanmath.github.io/tags/hadoop/"}]},{"title":"hadoop-4","slug":"hadoop-4","date":"2017-10-13T09:27:35.000Z","updated":"2017-10-13T10:20:46.027Z","comments":true,"path":"2017/10/13/hadoop-4/","link":"","permalink":"https://nannanmath.github.io/2017/10/13/hadoop-4/","excerpt":"Hadoop start procedure.","text":"Hadoop start procedure. Processes start-dfs.sh NameNode SecondNameNode DataNode start-yarn.sh ResourceManager NodeManage Scripts sbin/start-all.sh libexec/hadoop-config.sh start-dfs.sh start-yarn.sh sbin/start-dfs.sh libexec/hadoop-config.sh sbin/hadoop-daemon.sh --config ... --hostname ... start namenode ... sbin/hadoop-daemons.sh --config ... --hostname ... start datanode ... sbin/hadoop-daemon.sh --config ... --hostname ... start secondarynamenode ... sbin/hadoop-daemon.sh --config ... --hostname ... start zkfc ... sbin/start-yarn.sh libexec/hadoop-config.sh sbin/yarn-daemon.sh start resourcemanager sbin/yarn-daemon.sh start nodemanager sbin/hadoop-deamons.sh libexec/hadoop-config.sh get slave node from slaves file hadoop-daemon.sh sbin/hadoop-deamon.sh libexec/hadoop-config.sh bin/hdfs ... Start process separately 1234$&gt; hadoop-daemon.sh start namenode // start namenode (run on master node)$&gt; hadoop-daemons.sh start datanode // start datanodes on 3 machines (run on master node, `hadoop-daemons.sh` will access slaves file)$&gt; hadoop-daemon.sh stop namenode // stop namenode (run on master node)$&gt; hadoop-daemon.sh stop datanode // stop datanode on that node who runs this command.","categories":[{"name":"BigData","slug":"BigData","permalink":"https://nannanmath.github.io/categories/BigData/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://nannanmath.github.io/tags/hadoop/"}]},{"title":"java-reflection","slug":"java-reflection","date":"2017-10-12T16:22:41.000Z","updated":"2017-10-26T06:29:18.108Z","comments":true,"path":"2017/10/13/java-reflection/","link":"","permalink":"https://nannanmath.github.io/2017/10/13/java-reflection/","excerpt":"Java reflection and introspector.","text":"Java reflection and introspector. Reflection Introduce Class descriptor Descripe features of class Class DOES NOT rewrite hashCode() (returns position in memory) 1234567891011121314151617// Persion is a class// Student is a class whitch extends Persionpublic void testClass()&#123; Persion p = new Persion(); Student s = new Student(); Class class1 = p.getClass(); Class class2 = Persion.class; System.out.println(p instanceof Persion) //true System.out.println(p.getClass() == Persion.class) //true System.out.println(s instanceof Persion) //true System.out.println(s.getClass() == Persion.class) //false System.out.println(class1 == class2); // true System.out.println(class1.hashCode() == class2.hashCode()); // true (position in memory) System.out.println(class1.getName()); // full name of Persion including package path&#125; Method, Field 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Person classclass Person &#123; private String name； public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; private void talk() &#123; System.out.println(\"This is a private methed!\"); &#125;&#125;public void testNewInstance() throw Exception &#123; /***Create Object Dynamically***/ // Load class, return Class object. Class clazz = Class.forName(\"nan.javalearn.reflection.Persion\"); // Make object by Class. Object obj = clazz.newInstance(); /***Method***/ // Get `setName()` of Person Method m1 = clazz.getDeclareMethod(\"setName\", String.class); // Call `setName()` m1.invoke(obj, \"tom\"); // Get `getName()` of Person Method m2 = clazz.getDeclareMethod(\"getName\"); Object ret = m2.invoke(obj); System.out.println(ret); // tom // Access private method Method mp = clazz.getDeclareMethod(\"talk\"); mp.setAccessible(true); // Set accessible. mp.invoke(obj); // Output: This is a private method! // diff `getDeclareMethods()` and `getMethods()` Method[] ms = clazz.getMethods(); for (Method mm : ms) &#123; Systom.out.println(mm); // All methods including that extends from super class. &#125; ms = clazz.getDeclareMethods(); for (Method mm : ms) &#123; System.out.println(mm); // Methods declared in this class. &#125; // Get all available methods start with \"get\". ms = clazz.getMethods(); for (Method mm : ms) &#123; String fname = mm.getName(); Class[] pytpes = mm.getParameterTypes(); if (fname.startsWith(\"get\") &amp;&amp; (ptypes == null || ptypes.length == 0)) &#123; int mod = mm.getModifiers(); // Get modifiers of this method. System.out.println(Modifer.isPublic(mod)); // If it is a public method. ret = mm.invoke(obj); System.out.println(fname + \" = \" + ret); &#125; &#125; /***Field***/ Field f = clazz.getDeclareField(\"name\"); f.setAccessible(true); ret = f.get(obj); System.out.println(ret); // Output: tom. f.set(obj, \"jerry\"); // set `name` to `jerry`.&#125; Constructor 12345678910111213public class Person2&#123; private String name; public Person2(String name) &#123; this.name = name; &#125;&#125;public void testConstructor() throw Exception &#123; Class clazz = Class.forName(\"nan.javalearn.reflect.Person2\"); Constructor cs = clazz.getDeclaredConstructor(String.class); Object obj = cs.newInstance(\"tom\"); System.out.println(obj);&#125; Copy Properties By Filed 12345678910111213141516public class Person3&#123; private String name; public Person3(String name) &#123; this.name = name; &#125;&#125;public void propCopy(Person3 p1, Person3 p2)&#123; Class clazz = p1.getClass(); Field[] fs = clazz.getDeclareFields(); for(Field f : fs) &#123; f.setAccessible(true); Object ret = f.get(a); f.set(b, ret); &#125;&#125; By Method Full code can be found in github 12345678910111213141516171819202122public static void copyProperty(Object a, Object b) &#123; Method[] ms = a.getClass().getDeclaredMethods(); Class bclazz = b.getClass(); for (Method m : ms) &#123; String mname = m.getName(); Class[] paramTypes = m.getParameterTypes(); Class retType = m.getReturnType(); if (mname.startsWith(\"get\") &amp;&amp; (paramTypes == null || paramTypes.length == 0) &amp;&amp; retType != void.class) &#123; String bmname = mname.replace(\"get\", \"set\"); try &#123; Method bm = bclazz.getDeclaredMethod(bmname, retType); Object retVal = m.invoke(a); bm.invoke(b, retVal); &#125; catch (Exception e) &#123; continue; &#125; &#125; &#125;&#125; Other examples Proxy pattern full code Build object from config file full code","categories":[{"name":"Program","slug":"Program","permalink":"https://nannanmath.github.io/categories/Program/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nannanmath.github.io/tags/Java/"}]},{"title":"jvm","slug":"jvm","date":"2017-10-11T14:29:39.000Z","updated":"2017-10-12T02:20:13.644Z","comments":true,"path":"2017/10/11/jvm/","link":"","permalink":"https://nannanmath.github.io/2017/10/11/jvm/","excerpt":"Introduce some concepts about JVM.","text":"Introduce some concepts about JVM. Runtime data area Method area class descriptor class loaded once only, Class.forName(&quot;xxx&quot;) shared by threads Heap objects and arrays shared by threads Java stack each thread needs a stack each process has one thread at least Native method stack native methods Program counter register JVM memory Heap Young Eden space Survivor-0 space Survivor-1 space Old Old generation space Non-heap Meta space Code cache Compressed class space Monitors jvisualvm Open 1$&gt; jvisualvm // open jvisualvm Plugin Tools –&gt; Plugins –&gt; visual gc –&gt; install jconsole mem: heap and non-heap jmap 123$&gt; jmap -heap pid // show heap info$&gt; jmap -permstat pid // show permnent space info$&gt; jmap -clstats pid // show class loader info Modify heapDebug --&gt; Debug Configurations --&gt; Arguments --&gt; VM arguments `-Xms` --&gt; set heap initial size (1/64 mem size)[`-Xms300m`] `-Xmx` --&gt; set heap max size (1/4 mem size)[`-Xmx300m`] `-Xmn` --&gt; set young space size (eden + s0 + s1)[`-Xmn150m`] `-XX:NewSize` --&gt; set young space size [`-XX:NewSize=150m`] `-XX:MaxNewSize` --&gt; set young space max size [`-XX:MaxNewSize=150m`] `-XX:PermSize` --&gt; set permnent space size [`-XX:PermSize=150m`] `-XX:MaxPermSize` --&gt; set permnent space max size [`-XX:MxPermSize=150m`] --------- young space : old space = 1 : 2 eden : survivor = 3 : 1 ClassLoader","categories":[{"name":"BigData","slug":"BigData","permalink":"https://nannanmath.github.io/categories/BigData/"}],"tags":[{"name":"java","slug":"java","permalink":"https://nannanmath.github.io/tags/java/"}]},{"title":"hadoop-3","slug":"hadoop-3","date":"2017-10-09T09:29:17.000Z","updated":"2017-10-13T08:27:29.113Z","comments":true,"path":"2017/10/09/hadoop-3/","link":"","permalink":"https://nannanmath.github.io/2017/10/09/hadoop-3/","excerpt":"Full destributed module.","text":"Full destributed module. DesignNameNode: s201 DataNode: s202, s203, s204 Config of Hadoop core-site.xml 1234&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://s201/&lt;/value&gt;&lt;/property&gt; hdfs-site.xml 1234&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt;&lt;/property&gt; There are 3 datanodes. mapred-site.xml Don not need to modify. yarn-site.xml 12345678&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;s201&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt; resourcemanager is s201. Clear Remove all of ${HADOOP_HOME}/logs and /tmp.Clone VMs and Test Clone Clone –&gt; Create a full done Config hostname and network hostname Edit /etc/sysconfig/network Change HOSTNAME=s20x Network IP Edit /etc/sysconfig/network-scripts/ifcfg-ehtx Remove HWADDR and UUID Change IPADDR=xxx.xxx.xxx.20x Card info Remove /etc/udev/rules.d/70-persistent-net.rules Restart network Ssh without password Config s201 login others without password. Start hadoop 12$&gt; hadoop namenode -format$&gt; start-all.sh WebUI: http://192.168.137.201:50070 Click Datanodes –&gt; 3 datanodes Config by script Install rsync package Edit xcall.sh to run command on all nodes 1234567891011121314#!/bin/bashparam=$@ip=201if [ $# -lt 1 ]; then echo parameters less than 1 exit 1fifor (( ; ip&lt;=204; ip=$ip+1 )); do echo =============host: $&#123;ip&#125;============ ssh s$ip \"$&#123;param&#125;\"done Edit xrsync.sh copy file to other nodes 12345678910111213141516171819#!/bin/bashif [ $# -lt 1 ]; then echo no param exit 1fipath=$1dir=$(dirname $path)filename=$(basename $path)cd $dirfullpath=$(pwd -P .)user=$(whoami)for (( ip=202; ip&lt;=204; ip=$ip+1 )); do echo ============node: s$ip============= rsync -lr $&#123;path&#125; $&#123;user&#125;@s$&#123;ip&#125;:$&#123;fullpath&#125;done","categories":[{"name":"BigData","slug":"BigData","permalink":"https://nannanmath.github.io/categories/BigData/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://nannanmath.github.io/tags/hadoop/"}]},{"title":"hadoop-2","slug":"hadoop-2","date":"2017-10-09T05:15:09.000Z","updated":"2017-10-11T02:41:17.647Z","comments":true,"path":"2017/10/09/hadoop-2/","link":"","permalink":"https://nannanmath.github.io/2017/10/09/hadoop-2/","excerpt":"Use Hadoop pesudo distributed.","text":"Use Hadoop pesudo distributed. Start Hadoop Specify Env for Hadoop Edit ${HADOOP_HOME}/etc/hadoop/hadoop_env.sh 1export JAVA_HOME=/opt/jdk Start all processes Format and start 123$&gt; hadoop namenode -format // format file system$&gt; start-all.sh // start all processes$&gt; jps // check processes Check file system by WebUI 1$&gt; /etc/init.d/iptables stop // stop firewall Open in browser: http://localhost:50070 Check HDFS file system 123$&gt; hdfs dfs -ls /$&gt; hdfs dfs -mkdir -p /usr/centos01/hadoop // make a directory$&gt; hdfs dfs -lsr / Hadoop Introduce Hadoop ports 50070 –&gt; namenode http port 50075 –&gt; datanode http port 50090 –&gt; 2nd namenode http port 8020 –&gt; namenode rpc port 50010 –&gt; datanode rpc port Hadoop 4 modules common + hdfs NameNode, SecondaryNameNode, DataNode mapred + yarn NodeManager, ResourceManager Hadoop scripts ALL start-all.sh: start all nodes stop-all.sh: stop all nodes HDFS start-dfs.sh: NameNode, DataNode, 2ndNameNode stop-dfs.sh : YARN: start-yarn.sh: NodeManager, ResourceManager stop-yarn.sh:","categories":[{"name":"BigData","slug":"BigData","permalink":"https://nannanmath.github.io/categories/BigData/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://nannanmath.github.io/tags/hadoop/"}]},{"title":"hadoop-1","slug":"hadoop-1","date":"2017-10-08T09:14:19.000Z","updated":"2017-10-12T07:48:06.269Z","comments":true,"path":"2017/10/08/hadoop-1/","link":"","permalink":"https://nannanmath.github.io/2017/10/08/hadoop-1/","excerpt":"Start to introduce Hadoop.","text":"Start to introduce Hadoop. Show Full Path in TermEdit /etc/profile add:1export PS1='[\\u@\\h `pwd`]\\$' $&gt; source /etc/profile Install JDK8 Install from tar.gz package. Decompress the package. Edit /etc/profile file add PATH 12export JAVA_HOME=/path/to/jdkexport PATH=$PATH:$JAVA_HOME/bin Test 12$&gt; source /etc/profile$&gt; java -version Install Hadoop2.7 Download tar.gz package. Decompress the package. Edit /etc/profile file add PATH 12export HADOOP_HOME=/path/to/jdkexport PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin Test 123$&gt; source /etc/profile$&gt; hadoop version$&gt; hdfs dfs -ls \\ Hadoop Configuration Standalone(local) mode Pseudoditributed mode cd into ${HADOOP_HOME}/etc/hadoop edit files edit core-site.xml 1234567&lt;?xml version=\"1.0\"?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost/&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; edit hdfs-site.xml 1234567&lt;?xml version=\"1.0\"?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; edit mapred-site.xml $&gt; cp mapred-site.xml.template mapred-site.xml 1234567&lt;?xml version=\"1.0\"?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; edit yarn-site.xml 1234567891011&lt;?xml version=\"1.0\"?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;localhost&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; SSH Three packages 123openssh ---&gt; ssh-keygenopenssh-client ---&gt; sshopenssh-server ---&gt; sshd Check ssh 12$&gt; yum list installed ssh // check `openssh` `openssh-server` `openssh-client`$&gt; ps -Af | grep sshd // check if has sshd process Generate ssh keys in client 1$&gt; ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa ~/.ssh/id_rsa/id_rsa is private key and ~/.ssh/id_rsa/id_rsa.pub is public key. Append public key to ~/.ssh/authorized_keys in server12$&gt; cat id_rsa.pub &gt;&gt; authorized_keys$&gt; chmod 644 authorized_keys // turn off write permission of group and others Full Distributed Config by link file Create 3 config folders as ${HADOOP_HOME}/etc/hadoop: 123$&#123;HADOOP_HOME&#125;/etc/local$&#123;HADOOP_HOME&#125;/etc/pesudo$&#123;HADOOP_HOME&#125;/etc/full Make symbolic link to needed $&gt; link -s pesudo hadoop // switch to pesudo mode","categories":[{"name":"BigData","slug":"BigData","permalink":"https://nannanmath.github.io/categories/BigData/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://nannanmath.github.io/tags/hadoop/"}]},{"title":"How to install CentOS Linux on VMware 12","slug":"vmware-centos","date":"2017-10-03T10:30:30.000Z","updated":"2017-10-12T08:04:27.684Z","comments":true,"path":"2017/10/03/vmware-centos/","link":"","permalink":"https://nannanmath.github.io/2017/10/03/vmware-centos/","excerpt":"This post will introduce how to install a CentOS on VMware 12.","text":"This post will introduce how to install a CentOS on VMware 12. Install CentOSCustom –&gt; I will install the operating system later. Good Commands1234567891011121314151617181920212223242526272829303132$&gt; more a.txt // more display$&gt; more -5 a.txt // display the first 5 lines$&gt; ls -aR ~ // list all recursively$&gt; head a.txt // display the first 10 lines$&gt; head -n 12 a.txt // display the first 12 lines$&gt; head -n -10 a.txt // display all but the last 10 lines$&gt; tail a.txt // display the last 10 lines$&gt; tail -n 12 a.txt // the last 12 lines$&gt; wc -c a.txt // display the byte counts$&gt; wc -m a.txt // print the char counts$&gt; wc -l a.txt // print the line counts$&gt; wc -w a.txt // display the word counts$&gt; wc -L a.txt // print the length of the longest line$&gt; hostname$&gt; uname -a // print all information about system$&gt; file a.so // print type of a file$&gt; xargs // convert multi lines to single line$&gt; find . | grep txt | cp `xargs` temp // copy all 'txt' files from `find` command to `temp` directory$&gt; which echo // find where command `echo` is$&gt; chmod g+w a.txt // add write permission to group$&gt; chown -h xxx:xxx linker // change a linker owner but not object$&gt; ln -sfT linker newObject // change a linker from old to new Net Configuration Network modes Bridged Connect virtual machine to Internet directly by physical netcard. Other machines can access virtual machine directly. NAT(Net Address Tranform) virtual machine can access other machines. Other machines can not access virtual machine. Host-only Like NAT but can not connect to Internet. Static IP Address Edit file: /etc/sysconfig/network-scripts/ifcfg-enoxxxxx These values should be modified: 123456ONBOOT=yesNM_CONTROLLED=noBOOTPROTO=staticIPADDR=xxx.xxx.xxx.xxxNETMASK=xxx.xxx.xxx.xxxGATEWAY=xxx.xxx.xxx.xxx NETMASK and GATEWAY must be same with your VMnet8(NAT mode). Edit file: /etc/resolv.conf for DNS 1nameserver xxx.xxx.xxx.xxx nameserver must be same with VMnet8 gateway. Jobs 123456$&gt; cat a.txt &amp; // run in background$&gt; jobs // check jobs in background$&gt; fg %n // switch job to foreground, `n` is job IDctrl + z // switch job to background$&gt; bg %n // continue a job in background$&gt; kill %n // kill a job Process 12$&gt; ps -Af // show all processes$&gt; top Cut 1$&gt; cut -c 1-5 a.txt // show the 1st - 5th chars in each lines Device Info 12$&gt; fdisk -l /dev/sda // show infos of `sda` like partitions$&gt; df -ah // show free space of devices Host name 1$&gt; hostname // show host name change host name to edit /etc/hostname file. Host name to IP address Edit file /etc/hosts 12127.0.0.1 localhostxxx.xxx.xxx.xxx host1 Nested Commands 123$&gt; echo www.baidu.com &gt; a.txt$&gt; echo `cat a.txt`$&gt; ping $(echo $(cat a.txt)) Add and Delete users 12$&gt; useradd -m newuser // add new user$&gt; userdel -rf newuser // delete new user Env variable 123$&gt; echo $&#123;PATH&#125;$&gt; echo \"$PATH\"$&gt; export mypath=$&#123;name:-$PATH&#125; // ternary operator Parameters of scripts 123456$? // return value$# // number of params$n // the n-th param$0 // current name of script$@ // get all paramsshift // left move param IfAn example of if: 12345678910111213#!/bin/bashif [ $# -lt 2 ]; then echo less than 2!elif [ $# -gt 2 ]; then echo greater then 2!else echo good!fiecho ==============echo param number is: $#echo all params are: $@echo the 2nd param is: $2echo current script name is: $0 ForAn example of for“ 12345678#!/bin/bashlines=5for (( x=1; x&lt;=lines; x=$x+1 )); do for (( y=1; y&lt;=$x; y=$y+1 )); do echo -n $ye done echodone YUM Repository 123$&gt; mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup$&gt; curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo$&gt; yum makecache Yum Commands 1234567$&gt; yum list // list all packages$&gt; yum list installed // list all installed packages$&gt; yum search xxx // search xxx in repos$&gt; yum remove xxx // remove an installed package xxx$&gt; yum install xxx // install a package$&gt; yum [re]install --downloadonly --downloaddir=/home/xxx wget // download wget packages into /home/xxx$&gt; yum localinstall xxx.rpm // local install a rpm Make ISO file 12$&gt; yum install mkisofs$&gt; mkisofs -r -o xxx.iso yyy // make xxx.iso from dir yyy","categories":[{"name":"BigData","slug":"BigData","permalink":"https://nannanmath.github.io/categories/BigData/"}],"tags":[{"name":"Environment","slug":"Environment","permalink":"https://nannanmath.github.io/tags/Environment/"}]},{"title":"function wrap","slug":"function-wrap","date":"2017-06-22T06:24:15.000Z","updated":"2017-10-09T04:21:06.316Z","comments":true,"path":"2017/06/22/function-wrap/","link":"","permalink":"https://nannanmath.github.io/2017/06/22/function-wrap/","excerpt":"This post will introduce a C++ 11 feature, std::function. It can wrap any kind of callable element into a copyable object and whose type depands soly on its call signature.","text":"This post will introduce a C++ 11 feature, std::function. It can wrap any kind of callable element into a copyable object and whose type depands soly on its call signature. std::function is an object who can replace the function poiner in C language but more safety. It is useful for implement of many C++ design patterns. std::function123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdlib&gt;#include &lt;functional&gt;#include &lt;vector&gt;typedef std::function&lt;int(int,int)&gt; IntOpFun;struct Adder &#123; int OnAB(int iA, int iB) &#123; printf(\"Add(%d,%d)=%d\", iA, iB, iA + iB); return iA + iB; &#125;&#125;; struct Muler &#123; int OnAB(int iA, int iB) &#123; printf(\"Mul3(%d,%d)=%d\", iA, iB, iA * iB); return iA * iB; &#125;&#125;;struct Subject &#123; void AddObserver(IntOpFun of) &#123; m_vecOf.push_back(of); &#125; void Notify(int iA, int iB) &#123; for (auto iter = m_vecOf.begin(); iter != m_vecOf.end(); ++iter) &#123; (*iter)(iA, iB); &#125; &#125; std::vector&lt;IntOpFun&gt; m_vecOf;&#125;;int main() &#123; Subject3 subj; Adder3 adder; Muler3 muler; subj.AddObserver(std::bind(&amp;Adder3::OnAB, &amp;adder, std::placeholders::_1, std::placeholders::_2)); subj.AddObserver(std::bind(&amp;Muler3::OnAB, &amp;muler, std::placeholders::_1, std::placeholders::_2)); subj.Notify(1, 2); return 0;&#125;","categories":[{"name":"Program","slug":"Program","permalink":"https://nannanmath.github.io/categories/Program/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://nannanmath.github.io/tags/c/"}]},{"title":"operator overloading","slug":"operator-overloading","date":"2017-06-21T08:16:10.000Z","updated":"2017-10-09T04:21:06.326Z","comments":true,"path":"2017/06/21/operator-overloading/","link":"","permalink":"https://nannanmath.github.io/2017/06/21/operator-overloading/","excerpt":"This post will introduce how to overload different operators in C++ language.","text":"This post will introduce how to overload different operators in C++ language. Some important operators input and output operators: &lt;&lt;, &gt;&gt;. assignment operator: =. subscript operator: []. pre- and post- increament operator: ++, --. call operator: (). simple operators overloading123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;iostream&gt;using namespace std; class CA &#123; public: // constructor and distructor. CA(): count(0), book(\"\") &#123;&#125; CA(int cnt): count(cnt),book(\"\") &#123;&#125; CA(string str); ~CA() &#123;&#125;; // copy constructor CA(const CA&amp; C); // IO '&lt;&lt;' and '&gt;&gt;' overloading. // They should be friend function and not belong to this class. friend ostream&amp; operator&lt;&lt;( ostream&amp; os, const CA&amp; C); friend istream&amp; operator&gt;&gt;( istream&amp; in, CA&amp; C); // Logical operators '==', '!=' overloading. bool operator == (const CA&amp; C); bool operator != (const CA&amp; C); // Subscript operator '[]' string&amp; operator [] (const size_t index); const string&amp; operator [] (const size_t index) const; // Pre-increment operators. CA&amp; operator ++ (); CA&amp; operator -- (); // Post-increment operators. CA operator ++ (int); CA operator -- (int); // Call operator. int operator () (vector&lt;string&gt; books); private: int count; // number of books in bks. string book; // the last books in bks. vector&lt;string&gt; bks; // container of books.&#125;;CA::CA(string str) &#123; this-&gt;count = 1; this-&gt;book = str; this-&gt;bks.push_back(str);&#125;// copy constructorCA::CA(const CA&amp; C) &#123; this-&gt;count = C.count; this-&gt;book = C.book; this-&gt;bks = C.bks;&#125;// '&lt;&lt;' operator overloading.ostream&amp; operator&lt;&lt;( ostream&amp; os, const CA&amp; C) &#123; os &lt;&lt; C.count &lt;&lt; \", last=\"&lt;&lt;C.book &lt;&lt; \" , books = \"; vector&lt;string&gt; books(C.bks); vector&lt;string&gt;::iterator iter; for(iter=books.begin(); iter != books.end(); ++iter) os &lt;&lt; *iter &lt;&lt; \", \" ; os &lt;&lt; \"\\n\";&#125;// '&gt;&gt;' operator overloading.istream&amp; operator&gt;&gt;( istream&amp; in, CA&amp; C) &#123; in &gt;&gt; C.book; if(in) &#123; // check if in is valid. C.bks.push_back(C.book); ++C.count; &#125; else &#123; cout &lt;&lt; \"---- input over ! -----\" &lt;&lt; endl; &#125; return in;&#125;// '==' operator.bool CA::operator == (const CA&amp; C) &#123; if((this-&gt;count == C.count) &amp;&amp; (this-&gt;book == C.book)) return true; return false;&#125;bool CA::operator != (const CA&amp; C) &#123; if(*this == C) return false; else return true;&#125;// '[]' operator.string&amp; CA::operator [] (const size_t index) &#123; return this-&gt;bks[index];&#125;// pre-increment// return the reference of this object.CA&amp; CA::operator ++ () &#123; ++this-&gt;count; this-&gt;book = \"-no-\"; this-&gt;bks.push_back(string(\"-no-\")); return *this;&#125;// post-increment// return a new object constructed from this object.CA CA::operator ++ (int) &#123; CA B(*this); ++this-&gt;count; this-&gt;book = \"-no-\"; this-&gt;bks.push_back(string(\"-no-\")); return B;&#125;CA&amp; CA::operator -- () &#123; --this-&gt;count; this-&gt;bks.pop_back(); size_t i = this-&gt;bks.end() - this-&gt;bks.begin(); cout &lt;&lt; \" i= \" &lt;&lt; i &lt;&lt; endl; this-&gt;book = (*this)[i-1]; return *this;&#125;CA CA::operator -- (int) &#123; CA B(*this); --this-&gt;count; this-&gt;bks.pop_back(); size_t i = this-&gt;bks.end() - this-&gt;bks.begin(); cout &lt;&lt; \" i= \" &lt;&lt; i &lt;&lt; endl; this-&gt;book = (*this)[i-1]; return B;&#125;// call operatorint CA::operator () (vector&lt;string&gt; books) &#123; vector&lt;string&gt;::iterator iter = books.begin(); for (; iter != books.end(); ++iter) &#123; this-&gt;count++; this-&gt;bks.push_back(*iter); &#125; if (iter != books.begin()) this-&gt;book = *(--iter); return this-&gt;count;&#125; Dereference operator Arrow operator -&gt;: Example: a-&gt;b. If a is a pointer pointing to an object has member b, then return b. If a is an object that has overloaded -&gt; operator, then call operator -&gt;(). When this return a pointer then run as above. arrow operator12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt; #include &lt;stdlib.h&gt; using namespace std; class A &#123; public: void Printf() &#123;cout &lt;&lt; \"I am A \" &lt;&lt; endl;&#125;&#125;;class B &#123; public: void Printf() &#123;cout &lt;&lt; \"I am B \" &lt;&lt; endl;&#125; A* operator-&gt;() &#123; return &amp;m_A;&#125; private: A m_A;&#125;;class D &#123; public: void Printf() &#123;cout &lt;&lt; \"I am C \" &lt;&lt; endl;&#125; B* operator-&gt;() &#123; return &amp;m_B; &#125; private: B m_B;&#125;;class E &#123; public: void Printf() &#123;cout &lt;&lt; \"I am E \" &lt;&lt; endl;&#125; B&amp; operator-&gt;() &#123; return m_B; &#125; private: B m_B;&#125;;int main() &#123; D d; d-&gt;Printf(); // I am B (d-&gt;() return pointer to B). d.operator-&gt;()-&gt;Printf(); // I am B (d.operator-&gt;() return pointer to B). d-&gt;operator-&gt;()-&gt;Printf(); // I am A (d-&gt;() return pointer to B, d-&gt;operator-&gt;() return pointer to A, // d-&gt;operator-&gt;()-&gt;Printf() return Printf() of A). E e; e-&gt;Printf(); // I am A (e-&gt;() return ref of B, B-&gt;() return pointer to A, // e-&gt;Printf() return Printf() of A). return 0;&#125; Derecerence operator: * deref operator1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt; #include &lt;stdlib.h&gt; using namespace std; class CA; // smart pointerclass C_Ptr &#123; C_Ptr(int *p): ip(p), use(1) &#123; cout&lt;&lt; \" init: use = \" &lt;&lt; use &lt;&lt; \", *ip=\" &lt;&lt; *ip&lt;&lt;endl;&#125; ~C_Ptr() &#123;&#125; int *ip; // pointer int use; // counter friend class CA;&#125;;class CA &#123; public: CA(int*p, int v): ptr(new C_Ptr(p)), val(v) &#123;&#125; ~CA() &#123; cout &lt;&lt; \"~CA(): use = \" &lt;&lt; ptr-&gt;use &lt;&lt; endl; if(--ptr-&gt;use == 0) &#123; cout &lt;&lt; \"free C_Ptr\" &lt;&lt;endl; delete ptr; &#125; &#125; int&amp; operator*() &#123; return *ptr-&gt;ip;&#125; // deref operator private: C_Ptr *ptr; int val;&#125;;","categories":[{"name":"Program","slug":"Program","permalink":"https://nannanmath.github.io/categories/Program/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://nannanmath.github.io/tags/c/"}]},{"title":"IO redirction","slug":"IO-redirction","date":"2017-06-19T03:47:15.000Z","updated":"2017-10-09T04:21:06.309Z","comments":true,"path":"2017/06/19/IO-redirction/","link":"","permalink":"https://nannanmath.github.io/2017/06/19/IO-redirction/","excerpt":"In some cases, programmer wants to redirect input or output as a file for debugging facility. This post will introduce how to redirect input and output in C and C++ program.","text":"In some cases, programmer wants to redirect input or output as a file for debugging facility. This post will introduce how to redirect input and output in C and C++ program. C LanguageIn C language, usually, scanf and printf are used for programming input and output in terminal respectively. To redirect them to a file, freopen() is a method. freopen12freopen(\"data.in\",\"r\",stdin);freopen(\"data.out\",\"w\",stdout); The code redirects standard input to data.in and output to data.out. C++ LanguageIn C++, iostream is commonly used for input and output, like std::cin and std::cout. For redirction, rdbuf() can assign them to a file. freopen1234567891011121314streambuf *cinbackup;streambuf *coutbackup;cinbackup = cin.rdbuf(); // back up cin's streambuf coutbackup = cout.rdbuf(); // back up cout's streambuf ifstream fin;ofstream fout; fin.open(\"data.in\");fout.open(\"data.out\"); cin.rdbuf(fin.rdbuf()); // assign file's streambuf to cin cout.rdbuf(fout.rdbuf()); // assign file's streambuf to cout cin.rdbuf(cinbackup); // restore cin's original streambufcout.rdbuf(coutbackup); The code above assign iostream to data.in and data.out.Then, it restores them to original streambuf.","categories":[{"name":"Program","slug":"Program","permalink":"https://nannanmath.github.io/categories/Program/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://nannanmath.github.io/tags/c/"}]},{"title":"smart pointer","slug":"smart-pointer","date":"2017-06-16T05:03:02.000Z","updated":"2017-10-09T04:21:06.328Z","comments":true,"path":"2017/06/16/smart-pointer/","link":"","permalink":"https://nannanmath.github.io/2017/06/16/smart-pointer/","excerpt":"This post will introduce two types of smart pointers, which can help programmers to manage objects allocated in heap.","text":"This post will introduce two types of smart pointers, which can help programmers to manage objects allocated in heap. unique_ptrunique_ptr can manage another object through a pointer and dispose of that object when the unique_ptr goes out of scope. unique_ptr ensure that there is only one smart pointer points to the object. The object is disposed of using the assiciated deleter when either fo the following happens: the managing unique_ptr object is destoryed unique_ptr object is assigned to another pointer via operator= or reset() The object can be disposed of using a user-supplied deleter by calling get_delter()(ptr). unique_ptr can manage a single object or a dynamically-allocated array of objects(allocated by new[]). For the latter, when the object is disposed, unique_ptr will call delete[] to distory the array of objects defautly. unique_ptr1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;#include &lt;fstream&gt;#include &lt;cassert&gt; struct B &#123; virtual void bar() &#123; std::cout &lt;&lt; \"B::bar\\n\"; &#125; virtual ~B() = default;&#125;;struct D : B &#123; D() &#123; std::cout &lt;&lt; \"D::D\\n\"; &#125; ~D() &#123; std::cout &lt;&lt; \"D::~D\\n\"; &#125; void bar() override &#123; std::cout &lt;&lt; \"D::bar\\n\"; &#125;&#125;; // a function consuming a unique_ptr can take it by value or by rvalue referencestd::unique_ptr&lt;D&gt; pass_through(std::unique_ptr&lt;D&gt; p) &#123; p-&gt;bar(); return p;&#125; int main() &#123; // unique ownership semantics &#123; auto p = std::make_unique&lt;D&gt;(); // p is a unique_ptr that owns a D auto q = pass_through(std::move(p)); assert(!p); // now p owns nothing and holds a null pointer q-&gt;bar(); // and q owns the D object &#125; // ~D called here // Runtime polymorphism demo &#123; std::unique_ptr&lt;B&gt; p = std::make_unique&lt;D&gt;(); // p is a unique_ptr that owns a D // as a pointer to base p-&gt;bar(); // virtual dispatch std::vector&lt;std::unique_ptr&lt;B&gt;&gt; v; // unique_ptr can be stored in a container v.push_back(std::make_unique&lt;D&gt;()); v.push_back(std::move(p)); // notice: v.push_back(p) causes compiler errors v.emplace_back(new D); for(auto&amp; p: v) p-&gt;bar(); // virtual dispatch &#125; // ~D called 3 times // Custom lambda-expression deleter &#123; std::unique_ptr&lt;D, std::function&lt;void(D*)&gt;&gt; p(new D, [](D* ptr)&#123; std::cout &lt;&lt; \"destroying from a custom deleter...\\n\"; delete ptr; &#125;); // p owns D p-&gt;bar(); &#125; // the lambda above is called and D is destroyed //Array form of unique_ptr demo &#123; std::unique_ptr&lt;D[]&gt; p&#123;new D[3]&#125;; &#125; // calls ~D 3 times&#125; get() and release() can return the raw pointer managed by unique_ptr object.release() will release the unique_ptr object from responsibility of deleting the managed object, but get() will not. get() and release()12345678910111213141516171819 // foo bar p // --- --- ---std::unique_ptr&lt;int&gt; foo; // nullstd::unique_ptr&lt;int&gt; bar; // null nullint* p = nullptr; // null null nullfoo = std::unique_ptr&lt;int&gt;(new int(10)); // (10) null nullbar = std::move(foo); // null (10) nullp = bar.get(); // null (10) (10)*p = 20; // null (20) (20)p = nullptr; // null (20) nullfoo = std::unique_ptr&lt;int&gt;(new int(30)); // (30) (20) nullp = foo.release(); // null (20) (30)*p = 40; // null (20) (40)delete p; // the program is now responsible of deleting the object pointed to by p // bar deletes its managed object automatically shared_ptrshared_ptr is a smart pointer that retains shared ownership of an object through a pointer. Several shared_ptr object may own the same object. The object is destoryed when either of following happens: the last remaining shared_ptr owning the object is destoryed. the last remaining shared_ptr owning the object is assigned another one via operator= or reset(). A typical shared_ptr holds two pointers: the stored pointer (return by get()). a pointer to control block.The control block pointers to a object that holds the number of shared_ptr who point to the managed object. A poor sample for shared_ptr implementation:sample for shared_ptr123456789101112131415161718192021222324252627282930313233343536373839404142template &lt;typename T&gt;class SmartPtr; // declare a template class for friend class.template &lt;typename T&gt;class U_Ptr &#123; // control block private: friend class SmartPtr&lt;T&gt;; // private friend class which can access members of control block. // all following are private means they can be called by friend class only. U_Ptr(T *ptr) :p(ptr), count(1) &#123; &#125; ~U_Ptr() &#123; delete p; &#125; int count; // counter for number of shared_ptr that points to the same object. // points to managed object. T *p; &#125;;template &lt;typename T&gt;class SmartPtr &#123; // smart pointer class public: SmartPtr(T *ptr) : rp(new U_Ptr&lt;T&gt;(ptr)) &#123; &#125; // contructor makes control block to manage object. SmartPtr(const SmartPtr&lt;T&gt; &amp;sp) :rp(sp.rp) &#123; ++rp-&gt;count; &#125; // copy constructor SmartPtr&amp; operator=(const SmartPtr&lt;T&gt;&amp; rhs) &#123; // assignment operator ++rhs.rp-&gt;count; if (--rp-&gt;count == 0) delete rp; rp = rhs.rp; return *this; &#125; T&amp; operator*() &#123; // overload * operator. return *(rp-&gt;p); &#125; T* operator -&gt;() &#123; // overload -&gt; operator. return rp-&gt;p; &#125; ~SmartPtr() &#123; // distructor if (--rp-&gt;count == 0) // when counter is 0, delete control block which lead to distruct managed object. delete rp; &#125; private: U_Ptr&lt;T&gt; *rp; // pointer to control block.&#125;;","categories":[{"name":"Program","slug":"Program","permalink":"https://nannanmath.github.io/categories/Program/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://nannanmath.github.io/tags/c/"}]},{"title":"Two ways for separating interface from implementation","slug":"Two-ways-for-separating-interface-from-implementation","date":"2017-06-13T03:33:52.000Z","updated":"2017-10-09T04:21:06.311Z","comments":true,"path":"2017/06/13/Two-ways-for-separating-interface-from-implementation/","link":"","permalink":"https://nannanmath.github.io/2017/06/13/Two-ways-for-separating-interface-from-implementation/","excerpt":"Usually, the providers of a program want to hide the module’s concrete technique implementation. In this post, two ways for this goal will be introduced. One is called pImpl, another is pure abstract class.","text":"Usually, the providers of a program want to hide the module’s concrete technique implementation. In this post, two ways for this goal will be introduced. One is called pImpl, another is pure abstract class. pImplpImpl means “pointer to Implementation” which is a C++ programming technique. It can remove the implementation details of a class from its object representation by placing them in a separate class. pImpl can break the compilation dependency, changes to the implementation will not cause recompilation. So if a library uses pImpl as its interface, new version of the library may change implementation while remaining the interface with older versions. As the object of the interface type controls the lifetime of object of the implementation type, the pointer to the implementation type is usually std::unique_ptr. widget.h123456789101112#include &lt;memory&gt;using namespace std;class widget &#123; public: widget(); void Dosomething(); private: class impl; // forward declaration of the implementation class std::unique_ptr&lt;impl&gt; pImpl; // to the forward-declared implementation class&#125;; widget.cpp12345678910#include \"widget.h\"#include \"Impl.h\"widget::widget() &#123; pImpl.reset(new Impl());&#125;widget::Dosomething() &#123; pImpl -&gt; Dosomething();&#125; Impl.h1234567891011#include \"widget.h\"using namespace std;class widget::Impl &#123; public: void Dosomething(); private: // some private members, // that will be hiden in class widget.&#125;; Impl.cpp12345#include \"widget.h\"void widget::Impl::Dosomething() &#123; // do something.&#125; Pure abstract classPure abstract class is the class which includes pure virtual functions as its member functions. This type of class should not be instantiated but used as a base class. Usually, it plays a role as an interface class in programming. ITest.h123456789101112#include &lt;memory&gt;using namespace std;class ITest &#123; public: virtual void Dosomething() = 0;&#125;;// define a factory.shared_ptr&lt;ITest&gt; Test_factory(); Test.h1234567891011121314#include \"ITest.h\"using namespace std;class Test : public ITest &#123; public: virtaul void Dosomething(); private: Test(); Test(const Test&amp;); Test&amp; operator=(const Test&amp;); protected: shared_ptr&lt;ITest&gt; Test_factory();&#125;; Test.cpp123456789#include \"Test.h\"void Test::Dosomething() &#123; // do something.&#125;shared_ptr&lt;ITest&gt; Test_factory() &#123; return shared_ptr&lt;ITest&gt;(new Test);&#125; To set constructor, copy constructor and assignment operator as private member, the object of implementation class can only be instantiated by factory function. Meanwhile, the factory function should be included as a protect member of implementation class for accessing its private constructor.","categories":[{"name":"Program","slug":"Program","permalink":"https://nannanmath.github.io/categories/Program/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://nannanmath.github.io/tags/c/"}]},{"title":"explicit constructor","slug":"explicit-constructor","date":"2017-06-07T09:08:00.000Z","updated":"2017-10-09T04:21:06.314Z","comments":true,"path":"2017/06/07/explicit-constructor/","link":"","permalink":"https://nannanmath.github.io/2017/06/07/explicit-constructor/","excerpt":"This post will introduce a key word explicit that can forbid the implicit type casting by constructor with only one parameter.","text":"This post will introduce a key word explicit that can forbid the implicit type casting by constructor with only one parameter. Implicit type castingIn C++ class, a constructor with only one parameter (or parameters with default values except the first one) has two functions. One is to contruct an object, another is that will be called when an implicit type casting is performed. However, this is not always good. In some cases, it will lead to logical error. implicit_casting1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyString &#123; public: MyString(const char* p) &#123; cout &lt;&lt; \"char constructor\" &lt;&lt; endl; &#125; MyString(int n) &#123; cout &lt;&lt; \"int constructor\" &lt;&lt; endl; &#125;&#125;;int main() &#123; MyString s1(\"Hello\"); // explicit call MyString(const char* p) MyString s2(1); // explicit call MyString(int n) MyString s3 = \"Hello\"; // implicit call MyString(const char* p) MyString s4 = 1; // implicit call MyString(int n) char chr = 'a'; MyString s5 = chr; // implicit call MyString(int n) with type casting return 0;&#125; The result is: result12345char constructorint constructorchar constructorint constructorint constructor // s5, implict casting In this case, chr is a char type and MyString s5 = chr; will be interpreted by compiler as MyString s5 = MyString((int)chr) where chr is implicitly cast to int. This logical error is caused by the constructor MyString(int n) which make this implicit casting enable. To avoid this, the key word explicit should be used to restrict it. implicit_casting1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyString &#123; public: MyString(const char* p) &#123; cout &lt;&lt; \"char constructor\" &lt;&lt; endl; &#125; explicit MyString(int n) &#123; cout &lt;&lt; \"int constructor\" &lt;&lt; endl; &#125;&#125;;int main() &#123; MyString s1(\"Hello\"); // explicit call MyString(const char* p) MyString s2(1); // explicit call MyString(int n) MyString s3 = \"Hello\"; // implicit call MyString(const char* p) MyString s4 = 1; // error, invalid conversion from ‘int’ to ‘const char*’ char chr = 'a'; MyString s5 = chr; // error, invalid conversion from ‘char’ to ‘const char*’ return 0;&#125; To restrict by explicit, only MyString(const char* p) can be used for implicit casting and it will cause compile-time error. Copy contructorThere are three cases where the implicit casting will be performed by copy constructor. An object is passed into a function by pass-by-value. An object is retured from a function by pass-by-value. Call like: Myclass myobj1 = myobj2; where myobj2 is another object of Myclass. So if restricting a copy constructor by explicit, all operations above will cause error in compiling. That means explicit is not a good design for copy constructor.","categories":[{"name":"Program","slug":"Program","permalink":"https://nannanmath.github.io/categories/Program/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://nannanmath.github.io/tags/c/"}]},{"title":"Copy Constructors and Assignment Operators","slug":"copy-constructors-and-assignment-operators","date":"2017-06-07T03:10:39.000Z","updated":"2017-10-09T04:21:06.313Z","comments":true,"path":"2017/06/07/copy-constructors-and-assignment-operators/","link":"","permalink":"https://nannanmath.github.io/2017/06/07/copy-constructors-and-assignment-operators/","excerpt":"This post will introduce two members in C++ class. The first is copy constructor that can perform a deep copy for member variables. Another one is assignment operator which is used to assign one to another by overloading = operator.","text":"This post will introduce two members in C++ class. The first is copy constructor that can perform a deep copy for member variables. Another one is assignment operator which is used to assign one to another by overloading = operator. Compiler providedUsually, if there is no copy constructors and assignment operator in a class, the compiler will give default ones of member-wise copy version. copy_constructor_and_assignment_operator12Myclass (const Myclass&amp; a)Myclass&amp; operator = (const Myclass&amp; a); which means, for a class:12345class MyClass &#123; int x; char c; std::string s;&#125;;the default copy constructor and assignment operator provided by compiler like:123456789101112// default copy constructor:MyClass::MyClass( const MyClass&amp; other ) : x( other.x ), c( other.c ), s( other.s ) &#123;&#125;// default assignment operator:MyClass&amp; MyClass::operator=( const MyClass&amp; other ) &#123; x = other.x; c = other.c; s = other.s; return *this;&#125; In many cases, this is sufficient. However, there are some circumstances where the member-wise copy version is not good enough. The commont reason of that is the object contains a raw pointer witch points to a block of memory. In this case, the member-wise copy is likely to lead to more than one pointers that points to the same block of memory which will be a heap curruption in objects destruction. To avoid this curruption, copy constructor and assignment operator need to be implemented. Copy constructor &amp; Assignment operatorcopy_constructor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class String &#123; public: String(const char* str); String(const String&amp; other); String&amp; operator=(const String&amp; other); ~String(); private: char *m_data;&#125;;String::String(const char* str) &#123; cout &lt;&lt; \"constructor\" &lt;&lt; endl; if (str == NULL) &#123; m_data = new char[1]; *m_data = '\\0'; &#125; else &#123; if (m_data) delete[] m_data; int length = strlen(str); m_data = new char[length + 1]; strcpy(m_data, str); &#125;&#125;String::String(const String&amp; other) &#123; cout &lt;&lt; \"copy constructor\" &lt;&lt; endl; int length = strlen(other.m_data); m_data = new char[length + 1]; strcpy(m_data, other.m_data);&#125;String&amp; String::operator=(const String&amp; other) &#123; cout &lt;&lt; \"assignment operator\" &lt;&lt; endl; if (this == &amp;other) &#123; return *this; &#125; else &#123; delete[] m_data; int length = strlen(other.m_data); m_data = new char[length + 1]; strcpy(m_data, other.m_data); return *this; &#125;&#125;String::~String() &#123; cout &lt;&lt; \"destructor\" &lt;&lt; endl; delete [] m_data;&#125;int main() &#123; cout &lt;&lt; \"a(\\\"abc\\\")\" &lt;&lt; endl; String a(\"abc\"); // constructor. cout &lt;&lt; \"b(\\\"cde\\\")\" &lt;&lt; endl; String b(\"cde\"); // constructor. cout &lt;&lt; \" d = a\" &lt;&lt; endl; String d = a; // copy constructor. (NOTE) cout &lt;&lt; \"c(b)\" &lt;&lt; endl; String c(b); // copy constructor. cout &lt;&lt; \"c = a\" &lt;&lt; endl; c = a; // assignment operator. cout &lt;&lt; endl;&#125; Many of the STL containers and algorithms require that an object should be copyable. Typically, this means that you need to have the copy constructor that takes a const reference. Disallow Copy constructor and Assignment operatorIn some cases, it is not a safe operation to copy or assign an object. So, its copy constructor or assignment operator should be disabled explicitly. The most commont way for this is to make private constructor or operator and provide no implementation. Generally, a macro can be used to simplify this procedure. Disallow_copy_and_assign12345678910111213// define a macro.#define DISALLOW_COPY_AND_ASSIGN(TypeName) \\ TypeName(const TypeName&amp;); void operator=(const TypeName&amp;)// use the macro.class Foo &#123; public: explicit Foo(int f); private: DISALLOW_COPY_AND_ASSIGN(Foo);&#125; push_back() of STL vector containerpush_back() operator in vector container will perform a deep-copy of object. Actually, push_back() will call insert() in low level. push_back_in_vector_container12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;typedef struct point &#123; int x; int y;&#125;Point;ostream&amp; operator&lt;&lt;(ostream&amp; output, const Point &amp;a) &#123; return output &lt;&lt; a.x &lt;&lt;\" \"&lt;&lt; a.y;&#125;int main() &#123; Point * a = new Point; vector&lt;Point&gt; PointList; a-&gt;x = 3; a-&gt;y = 4; PointList.push_back(*a); a-&gt;x = 4; a-&gt;y = 4; PointList.push_back(*a); a-&gt;x = 5; a-&gt;y = 4; PointList.push_back(*a); delete a; for (vector&lt;Point&gt;::iterator i = PointList.begin(); i != PointList.end(); i++) &#123; cout &lt;&lt; (*i)&lt;&lt; endl; &#125; return 0;&#125; result is:result1233 44 45 4","categories":[{"name":"Program","slug":"Program","permalink":"https://nannanmath.github.io/categories/Program/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://nannanmath.github.io/tags/c/"}]},{"title":"Type casting in C++","slug":"new1","date":"2017-05-26T09:51:31.000Z","updated":"2017-10-09T04:21:06.321Z","comments":true,"path":"2017/05/26/new1/","link":"","permalink":"https://nannanmath.github.io/2017/05/26/new1/","excerpt":"This post will introduce four specific casting operators that are most frequently used in C++ project. They include static_cast, dynamic_cast, const_cast and reinterpret_cast. The differences between of them will be told with some code samples.","text":"This post will introduce four specific casting operators that are most frequently used in C++ project. They include static_cast, dynamic_cast, const_cast and reinterpret_cast. The differences between of them will be told with some code samples. staic_cast &lt;type-id&gt; (expression)staic_cast should be the first considered operator for type conversion. It can perform upcast and downcast conversion but does not perform any type-safety checks. So, staic_cast is not a safe opeation for downcast conversion and up to programers to ensure the conversion is safe. However, staic_cast does not incur the overhead of the type-safety checks. dynamic_cast &lt;type-id&gt; (expression)dynamic_cast should be used for conversion of pointers or references to classes. This operator can ensure that the result of type conversion points to a valid complete object. Conversion by dynamic_cast includes pointer upcast (converting from pointer-to-derived to pointer-to-base) naturally as allowed as an implicit conversion. Specifically, when do a downcast (convert from pointer-to-base to pointer-to-derived) conversion, dynamic_cast will do a type check to ensure the pointed object is a valid complete object of the target type. So, dynamic_cast is a safe operator for downcast conversion. dynamic_cast1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;class Base &#123; virtual void dummy() &#123;&#125; &#125;;class Derived: public Base &#123; int a; &#125;;int main () &#123; try &#123; Base * pba = new Derived; Base * pbb = new Base; Derived * pd; pd = dynamic_cast&lt;Derived*&gt;(pba); if (pd==0) cout &lt;&lt; \"Null pointer on first type-cast.\\n\"; pd = dynamic_cast&lt;Derived*&gt;(pbb); if (pd==0) cout &lt;&lt; \"Null pointer on second type-cast.\\n\"; &#125; catch (exception&amp; e) &#123;cout &lt;&lt; \"Exception: \" &lt;&lt; e.what();&#125; return 0;&#125; The output is:dynamic_cast_output1Null pointer on second type-cast. const_cast &lt;type-id&gt; (expression)const_cast can set or remove the constness of the object pointed by a pointer. However, it should be noted that actually this type of casting is not designed for modifing the value of a const object, but for faciliting program. For example, if a const pointer needs to pass to a function that expects a non-const argument: const_cast12345678910111213#include &lt;iostream&gt;using namespace std;void print (char * str)&#123; cout &lt;&lt; str &lt;&lt; '\\n';&#125;int main () &#123; const char * c = \"sample text\"; print ( const_cast&lt;char *&gt; (c) ); return 0;&#125; The output is:const_cast1sample text This example above can work because in function print does not write to the pointer. Note that, it will cause undefined behavior to write to a removing constness of a pointed object. reinterpret_cast &lt;type-id&gt; (expression)reinterpret_cast can convert any pointer type to any other pointer type, even of unrelated classes. That means the operation in this conversion is a binary copy only and no check will be performed. reinterpret_cast can also cast pointers to or from integer types. The format in which the integer value represents a pointer is platform-specific. The operations which can be performed by reinterpret_cast but not static_cast are low-level operations based on reinterpreting the binary representations of the type. On most cases, this conversion results in code which is system-specific. const_cast1234class A &#123; /* ... */ &#125;;class B &#123; /* ... */ &#125;;A * a = new A;B * b = reinterpret_cast&lt;B*&gt;(a);","categories":[{"name":"Program","slug":"Program","permalink":"https://nannanmath.github.io/categories/Program/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://nannanmath.github.io/tags/c/"}]}]}